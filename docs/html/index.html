<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TicTacToeOverLan: TicTacToeOverLan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="TicTacToeOverLan-Draft1.png"/></td>
  <td id="projectalign">
   <div id="projectname">TicTacToeOverLan<span id="projectnumber">&#160;1.0.17</span>
   </div>
   <div id="projectbrief">TicTacToe Ultimate Edition supporting up to 6 players and a board of 32x32. Allows connections from multiple devices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('index.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">TicTacToeOverLan </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__d_1_2_8_clion_projects_2_tic_tac_toe_over_lan_2_r_e_a_d_m_e"></a></p>
<ol type="1">
<li>Overview</li>
<li>Idea</li>
<li>Implementation analysis</li>
<li>User manual</li>
<li>Developer guide</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>TicTacToeOverLan allows for up to 6 simultaneous players connected over the network. With port forwarding It should be possible to play over the internet. Custom board settings allow for a board of size 32x32 with custom win condition length.</p>
<div class="image">
<img src="tictactieoverlan-img1.png" alt=""/>
<div class="caption">
Screenshot of the game running</div></div>
    <hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
Idea</h1>
<p>The general idea is inspired by how minecraft handles it's worlds. We should have an option to launch an Internal Server by one of the Clients. Others would connect to it via a specified IP and port, or a url. The state of the game should be held and validated on the server. Board updates are going to be sent packaged with the whole board, as it's pretty small and shouldn't pose any performance concerns. The host should be the one managing the board settings, and requesting game starts and restarts.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
Networking</h2>
<p>The connections are going to be handled by WebSockets. The Windows api already contains methods for handling multiple connections at a time, making it quick to set up. Sadly that means, this implementation won't work on linux systems. A custom network protocol needs to be designed, so the server and client know what data is being transmitted and how to handle it.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
State Management</h2>
<p>The server should be the sole authoritative entity in the design. It should hold, manage and update the game state based on validated data, which arrives in the form of packets from the clients. The game state(board state) is going to be sent whole, to the clients for rendering and synchronization on each update. This doesn't pose any performance concerns on this scale.</p>
<p>After each move the server validates the move and checks if it's a winning one. Sending <span class="tt">boardStateUpdate</span>'s or <span class="tt">gameEnd</span> packets accordingly. The win condition is check by ray-casting in all directions from the last move and counting same pieces, if they equal or exceed the <span class="tt">winConditionLength</span> the server sends out <span class="tt">gameEnd</span> packets, finishing the round.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Client Rendering</h2>
<p>I chose SFML library for the GUI. It's simple enough, while giving the necessary tools to create a small working GUI application. It comes with built-in functions for shapes, text and event handling, but lacks any widget functionality. That means, implementing my own widgets for buttons, text fields and the board itself. I plan to use the minecraft widget implementation as the blueprint, while cutting out unnecessary parts. All widgets would implement the <span class="tt"><a class="el" href="class_widget.html" title="Abstract base class representing a UI element.">Widget</a></span> interface, which would contain methods like update, handleInput and render. Which is going to simplify the general usage in the game loop. Each widget is going to have a dedicated builder for ease of use. To declutter the render and update functions, each widget is going to get a displayCondition lambda, to know when and where to show up on screen. Button press or input events are going to launch callbacks for processing.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Binary Bundling</h2>
<p>The project should work as a standalone binary, which is going to require bundling all libraries statically inside, as well as the images and fonts. Unfortunately, this is going to overly bloat the size of the binary.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
Implementation analysis</h1>
<p>The final application follows a Client-Server architecture, even when playing locally. The project was implemented using C++26, using SFML for graphics and Winsock2 for networking.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Architecture &amp; Concurrency</h2>
<ul>
<li><b>Host-as-Server</b>: We avoid a dedicated binary. Instead, when a player chooses to "Host", the <span class="tt"><a class="el" href="class_game_client.html" title="The main application controller.   This class manages the entire lifecycle of the client application,...">GameClient</a></span> spins up an <span class="tt"><a class="el" href="class_internal_game_server.html" title="The authoritative server logic for the game.   Runs on a dedicated thread hosted by one of the client...">InternalGameServer</a></span> on a dedicated <span class="tt">std::thread</span>. Additionally, the current implementation allows for creating a Dedicated server easily, if desired.</li>
<li><b>Thread Safety</b>: Since the server runs in parallel to the rendering loop, shared resources and state management utilize <span class="tt">std::atomic</span> variables and <span class="tt">std::mutex</span> locks to prevent race conditions. Mainly used in debug logging, game ticks and within <span class="tt"><a class="el" href="class_rolling_average.html" title="Interface for calculating moving statistics over a stream of values.   Primarily used for performance...">RollingAverage</a></span>.</li>
<li><b>Game Loop</b>: The client operates on a standard <em>Input</em> → <em>Update</em> → <em>Render</em> loop, while the server maintains its own tick rate to process incoming packets and broadcast state updates.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Networking Protocol</h2>
<p>Contrary to the initial WebSocket idea, I went for Raw TCP Sockets to better understand how webservers work, also standard WebSockets were a bit overkill for a project like this. The implementation utilizes the Windows Sockets API (Winsock2).</p><ul>
<li><b>Binary Protocol</b>: Communication relies on a custom binary protocol. Data is structured into <span class="tt">Packets</span> defined with <span class="tt">#pragma pack(1)</span> to ensure byte-perfect alignment across different architectures.</li>
<li><b>Packet Handling</b>:<ul>
<li><b>Header-Payload Separation</b>: Every transmission is prefixed with a <a class="el" href="struct_packet_header.html" title="The Standard Header prepended to ALL network messages.   The receiver reads these bytes first to dete...">PacketHeader</a> (containing <span class="tt"><a class="el" href="_network_protocol_8h.html#a0628f13bcd4685c7a4b4a9f1aad83b56" title="Identifiers for the specific type of payload contained in a packet.   Used by the receiver to cast th...">PacketType</a></span> and <span class="tt">size</span>), allowing the receiver to determine exactly how many bytes to read next.</li>
<li><b>Stream Fragmentation</b>: The <span class="tt"><a class="el" href="class_network_manager.html" title="Manages low-level TCP network communication.   Wraps the Winsock API to provide a cleaner interface f...">NetworkManager</a></span> has a buffering system (<span class="tt">recieveBuffer</span>) to handle fragmented TCP packets, ensuring that partial packets are stored until the full payload arrives.</li>
</ul>
</li>
<li><b>Serialization</b>: The dynamic <span class="tt">std::vector</span> board state is "flattened" into static 1D arrays using <span class="tt"><a class="el" href="class_utils.html#a71b0066a7749e408841c15ee5ff4f490" title="Flattens the 2D dynamic grid into a 1D static array for networking.   Converts the logical std::vecto...">Utils::serializeBoard</a></span> for network transmission, then reconstructed into 2D vectors upon arrival.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Custom GUI System</h2>
<p>SFML provides the window and drawing primitives(shapes and text), but lacks high-level components, like buttons or text fields. A custom <a class="el" href="class_widget.html" title="Abstract base class representing a UI element.">Widget</a> System was implemented to handle that.</p><ul>
<li><b>Unified</b>: All UI elements(<span class="tt"><a class="el" href="class_button_widget.html" title="A Widget implementation representing a clickable button. Handles visual states (Idle,...">ButtonWidget</a></span>, <span class="tt"><a class="el" href="class_text_field_widget.html" title="A Widget allowing user text input. Handles focus states (clicking to activate), keyboard events (typi...">TextFieldWidget</a></span>) inherit from an abstract <span class="tt"><a class="el" href="class_widget.html" title="Abstract base class representing a UI element.">Widget</a></span> base class, enforcing a contract for handleEvent, update and render methods.</li>
<li><b>Builder Pattern</b>: To reduce boilerplate in the initialization phase and improve the developer experience, widgets use the <b>Builder Pattern</b> (<span class="tt"><a class="el" href="class_button_builder.html" title="A Builder class for constructing ButtonWidget instances.">ButtonBuilder</a></span>, <span class="tt"><a class="el" href="class_text_field_builder.html" title="A Builder class for constructing TextFieldWidget instances.">TextFieldBuilder</a></span>). This allows chaining method calls (e.g. <span class="tt"><a class="el" href="class_button_widget.html#a2d42a2f9e1c33f5c726c827b5814cb05" title="Static factory method to start the Builder chain.">ButtonWidget.builder()</a>.setPosition().setSize().build())</span>) for readable UI creation.</li>
<li><b>Callbacks</b>: UI logic is decupled from game logic using <span class="tt">std::function</span> lambdas. Widgets trigger callbacks (e.g. <span class="tt">onClick</span>, <span class="tt">onTextChange</span>) rather than handling game state directly.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
Game Logic And State Management</h2>
<ul>
<li><b>Authoritative State</b>: The server holds the "True" state of the board. Clients send <span class="tt">MoverRequestPacket</span>'s, which the server validates before applying.</li>
<li><b>Snapshot Synchronization</b>: To ensure total consistency, the server broadcasts the <em>entire</em> board state (<span class="tt"><a class="el" href="struct_board_state_update_packet.html" title="Event-based full state synchronization.   Sent by the server to ensure all clients have the exact sam...">BoardStateUpdatePacket</a></span>) after every valid move. This eliminates "desync" issues where a client might miss a single move packet.</li>
<li><b>Win Validator</b>: Victory detection uses an optimized <b>Directional Ray-casting</b> algorithm (<span class="tt"><a class="el" href="class_win_validator.html" title="Logic for detecting victory conditions on the board.   Uses a raycasting algorithm to count consecuti...">WinValidator</a></span>). Instead of scanning the whole board (O(N^2)), it scans only the axes originating from the last placed piece, making the check efficient even on larger board sizes(up to 32x32).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Debug Info</h2>
<p>To help with testing and state verification, a real-time Debug Overlay was implemented into the rendering loop. Toggled via the <span class="tt">F3</span> key, this bypasses the standard widget system and prints raw telemetry data directly onto the screen.</p><ul>
<li><b>Client Section</b>: It displays local state variables, and the local view of the player list.</li>
<li><b>Internal Server Section</b>: When the client is acting as the Host, the overlay additionally renders a section for the <span class="tt"><a class="el" href="class_internal_game_server.html" title="The authoritative server logic for the game.   Runs on a dedicated thread hosted by one of the client...">InternalGameServer</a></span>. Displays servers status, tick count, <span class="tt"><a class="el" href="class_rolling_average.html" title="Interface for calculating moving statistics over a stream of values.   Primarily used for performance...">RollingAverage</a></span> tick times and the authoritative game settings. Which allows to verify the data and its synchronization, between the client's local state and the server's without attaching an external debugger.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
User Manual</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Prerequisites</h2>
<p>Before compiling, ensure you have the following tools installed and added to PATH.</p><ol type="1">
<li><b>CMake</b><ul>
<li>Version 4 or newer</li>
</ul>
</li>
<li><b>Compiler of your choice</b><ul>
<li>Since the project uses <b>C++26</b>, a very recent version is required (GCC 14 or newer)</li>
<li>For development MinGW-w64-15.2.0 was used. Acquired from (<a href="https://www.mingw-w64.org/downloads/#mingw-w64-builds">https://www.mingw-w64.org/downloads/#mingw-w64-builds</a>) (<a href="https://github.com/niXman/mingw-builds-binaries/releases">https://github.com/niXman/mingw-builds-binaries/releases</a>)</li>
</ul>
</li>
<li><b>Git</b><ul>
<li>Required by CMake to automatically download SFML.</li>
</ul>
</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Compilation</h2>
<p>Optionally the binary can be grabbed from the releases tab in the GitHub repo: <a href="https://github.com/Bebomny/TicTacToeOverLan/releases">https://github.com/Bebomny/TicTacToeOverLan/releases</a></p>
<ol type="1">
<li>Clone the project <div class="fragment"><div class="line">git clone https://github.com/Bebomny/TicTacToeOverLan.git </div>
</div><!-- fragment --></li>
<li>Navigate into the directory and tell CMake to use MinGW as the compiler instead of looking for Visual Studio <div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake -G &quot;MinGW Makefiles&quot; ..</div>
</div><!-- fragment --></li>
<li>Compile. This may take a minute as CMake needs to compile SFML and WinApi. <div class="fragment"><div class="line">cmake --build .</div>
</div><!-- fragment --></li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Launching the Game</h2>
<p>After a successful build, the executable will be generated in the <span class="tt">build/</span> folder (or a subfolder inside <span class="tt">build</span>) As the images and fonts are bundled inside the binary, you're free to move it around, and It should still function as usual.</p>
<p>To launch it either double-click the executable, or launch it from the terminal: </p><div class="fragment"><div class="line">.\TicTacToeOverLan.exe</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Playing the Game</h2>
<p>The game is played in sessions. One player acts as the Host (Server), and others join as Clients.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Main Menu</h3>
<p>Upon launching, you will see the Main Menu.</p><ul>
<li><b><a class="el" href="struct_player.html" title="Represents a participant in the game.   Contains identification, statistics, and local state flags.">Player</a> name</b>: Here you can set the name of your player.</li>
<li><b>Server Address</b>: The address of the server to which you'd like to connect to. Can be a url or an IP address, the port by default is <span class="tt">27015</span></li>
<li><b>Connect Button</b>: Connects to the server at which address has been specified, needs to be a valid address in the form of <span class="tt">{ip/url}:{port}</span></li>
<li><b>Host button</b>: Clicking the host button, starts an internal server on the port specified in the address bar, by default <span class="tt">27015</span>. The server starts on the IP of the host machine. So Its reachable on the host via <span class="tt">localhost</span>, on LAN via the machines local IP, and over the broader internet if the port is forwarded through the router.</li>
</ul>
<div class="image">
<img src="tictactoeoverlan-img2.png" alt=""/>
<div class="caption">
Main Menu Screen</div></div>
    <h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Game Room</h2>
<p>Once connected, players gather in the Game Room.</p><ul>
<li><b>PlayerList</b>: Here you can see all connected players and their pieces.</li>
</ul>
<p><img src="tictactoeoverlan-img6.png" alt="" class="inline" title="Player List"/>    </p>
<ul>
<li><b>Game Settings (Host Only)</b>: The Host has exclusive control over the match rules:<ul>
<li><b>Board Size</b>: Adjust the grid size (from 1x1 up to 32x32).</li>
<li><b>Win Condition</b>: Set how many consecutive pieces are needed to win (e.g. 3, 4, 5).</li>
<li><em>Tip</em>: For larger boards (20x20), a win condition of 5 is recommended.</li>
</ul>
</li>
</ul>
<p><img src="tictactoeoverlan-img5.png" alt="" class="inline" title="Game Settings"/>    </p>
<ul>
<li><b>Starting</b>:<ul>
<li>Once all players are gathered, the Host can start the game with the "Start" button.</li>
</ul>
</li>
</ul>
<div class="image">
<img src="tictactoeoverlan-img3.png" alt=""/>
<div class="caption">
Game Room Screen</div></div>
    <h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Gameplay</h2>
<p>The game is turn-based.</p><ul>
<li><b>Your Turn</b>:<ul>
<li>When it is your turn, your cursor will be able to interact with the board.</li>
<li>Left-Click on an empty square to place your piece. You can see the piece you are playing as at the top of your screen.</li>
<li>Once placed, your move is sent to the server, and the turn passes to the next player.</li>
</ul>
</li>
</ul>
<p><img src="tictactoeoverlan-img8.png" alt="" class="inline" title="Your Turn"/>    </p>
<ul>
<li><b>Opponent's Turn</b>:<ul>
<li>You cannot place pieces. Wait for the other player to make their move, and for the server to broadcast the change.</li>
</ul>
</li>
<li><b>Winning</b>:<ul>
<li>The game ends immediately when a player aligns the required number of pieces horizontally, vertically, or diagonally.</li>
<li>A "Game End" screen will appear announcing the winner, and the current scores for the lobby.</li>
<li>The Host can then choose to start another match or return to the <b>Game Room</b>, returning to the game room resets the leaderboard.</li>
</ul>
</li>
</ul>
<div class="image">
<img src="tictactoeoverlan-img9.png" alt=""/>
<div class="caption">
Game End Screen</div></div>
    <hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Developer Guide</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
UI</h2>
<p>All widgets should implement the widget interface, and provide builder methods for ease of use. In the <span class="tt"><a class="el" href="class_game_client.html" title="The main application controller.   This class manages the entire lifecycle of the client application,...">GameClient</a></span> widgets are placed in a map, for retrieval by name, if necessary later. If it can be done, the condition for displaying and activating a widget should go into the displayCondition callback.</p>
<p>The board for now has a separate handler than widgets. If necessary It can be made a widget later on.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
GameClient</h2>
<p>Widgets are created in the initWidget function at the start of the application. Ideally this should be made into a screen system, but for a simple game like this it wasn't necessary. UI elements are put into position using preestablished <span class="tt">sf::Vector2f</span> and <span class="tt">sf::FloatRect</span> structures.</p>
<p>The client follows a <em>handleInput</em> → <em>update</em> → <em>render</em> loop. Each screen should have their own handle, update and render functions for readability. A screen system would improve this dramatically when considering expansion or refactoring of the project</p>
<p>The constructor establishes initial values, loads fonts and icons, creates the screen in a contract with SFML and the creates widgets in the <span class="tt">initWidgets</span> function.</p>
<p>Then the client runs in the <span class="tt">run</span> function calling <span class="tt">handleInput</span>, <span class="tt">update</span> and <span class="tt">render</span> functions in order. The loop runs on 60 updates per second, as per the window framerate set in the constructor.</p>
<p><br  />
</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Input Handling</h3>
<p>Here we poll all events that came in on this frame, first we check for the Window Close Event, then for global keyboard events such as the debug <span class="tt">F3</span> being pressed. Next is distributing events to all widgets, and finally handling non widget events in separate functions for each screen(<span class="tt">handleMenuInput</span>, <span class="tt">handleGameRoomInput</span>, <span class="tt">handleGameInput</span>).</p>
<p><span class="tt">HandleGameInput</span> is also responsible for sending move requests upon the players turn, as the gameBoard isn't a widget its checked here separately.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Updating</h3>
<p>The update function is responsible for handling widget updates, animations, and received packets. Firstly it updates all widgets, then proceeds to loop over all incoming packets, polling the <span class="tt"><a class="el" href="class_network_manager.html" title="Manages low-level TCP network communication.   Wraps the Winsock API to provide a cleaner interface f...">NetworkManager</a></span> for available full packets.</p>
<p>Then according to the packet header, it handles the data. For readability most packets got their own functions, instead of handling them directly in the switch statement. S2C Packets:</p><ul>
<li><span class="tt">SERVER_HELLO</span>: Packet received from the server upon initial connection. We receive the playerID here, and then send <span class="tt">SETUP_REQ</span> with the confirmed ID, player name, initialToken, and whether we are the host.</li>
<li><span class="tt">SETUP_ACK</span>: Server accepted our <span class="tt">SETUP_REQ</span> and responded with the generated AuthToken, player's pieceType, and the initial Board settings. We also receive the players currently residing in the lobby.</li>
<li><span class="tt">NEW_PLAYER_JOIN</span>: When a new player joins we receive this packet, it contains all info about the new player that the client is allowed to know like: <span class="tt">playerName</span>, <span class="tt">pieceType</span>, <span class="tt">isMe</span>, <span class="tt">isMyTurn</span>, current <span class="tt">wins</span>, and whether it's the <span class="tt">host</span>.</li>
<li><span class="tt">SETTINGS_UPDATE</span>: The host changed the board settings, we receive the new parameters here.</li>
<li><span class="tt">PLAYER_DISCONNECTED</span>: Received when a player disconnects, we just erase the corresponding player form the player list.</li>
<li><span class="tt">GAME_START</span>: <span class="tt"><a class="el" href="struct_game_start_packet.html" title="Signal to switch UI to the Board view and initialize grid.">GameStartPacket</a></span> also contains all board settings for a final confirmation as well as the starting player, and initialGameBoard. We set this all up for the game, and switch the client into <span class="tt">ClientState::Game</span>.</li>
<li><span class="tt">BOARD_STATE_UPDATE</span>: We deserialize the new board state, update the turn and round parameters, switching the acting player, and refreshing the player list.</li>
<li><span class="tt">BACK_TO_GAME_ROOM</span>: This is sent when the Host chose to return to the Game Room, so the clients can update their state and screens accordingly.</li>
<li><span class="tt">GAME_END</span>: This packet is received upon either a player winning or disconnecting. Finishing the current round. The host can then choose to return to the Game Room or play again.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Rendering</h3>
<p>We clear the background, then render each menu's text, or other things in the separate screen functions. The widgets are rendered on top of the text. The debug menu is drawn on the absolute top of the screen, ensuring its always visible.</p>
<p>Text is rendered mostly by reusing one text object, this minimizes font loading calls, and maybe marginally improves performance.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Server Address Parsing</h3>
<p>A RegEx pattern is used for server address and port parsing, it checks if its valid and separates the ip/url and port into 2 capturing groups. </p><div class="fragment"><div class="line">^((?:\D+).\w{2,8}|(?:\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))):(\d{1,5}\b)$</div>
</div><!-- fragment --><p> <b>Examples:</b></p><ul>
<li>192.168.2.32:27015 → <b>valid</b> → Group 1: 192.168.2.32 Group 2: 27015</li>
<li>domain.example.com:27015 → <b>valid</b> → Group 1: domain.example.com Group 2: 27015</li>
<li>129.212.913.123:12312 → <b>invalid</b></li>
<li>localhost:27015 → <b>valid</b> → Group 1: localhost Group 2: 27015</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Internal Server Handling</h3>
<ul>
<li><span class="tt">startInternalServerThread</span>: Grabs the port from the server address field using the above parsing regex, and launches a new thread with the internal server.</li>
<li><span class="tt">stopInternalServerThread</span>: Called either by pressing the HOST button in the main menu again after launching the server, or in the destructor of the <a class="el" href="class_game_client.html" title="The main application controller.   This class manages the entire lifecycle of the client application,...">GameClient</a>, to ensure that no zombie orphaned threads are left behind.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Internal Game Server</h2>
<p>The <span class="tt">start</span> function initializes default values, the initial board state and available pieces. Creates a listing socket on the specified port and spins up a while loop for polling the Windows api for packets, initial timeout is set to 10ms between polls. Should be made dynamic later to keep a constant TPS value instead of trying to reach the 10ms interval.</p>
<p>When a new connection arrives, the server creates a new <a class="el" href="struct_client_context.html" title="Represents a connected client within the InternalGameServer.   Holds the raw socket,...">ClientContext</a> for the incoming connection and sends a <span class="tt">SERVER_HELLO</span> packet with the generated playerID. C2S Packets:</p><ul>
<li><span class="tt">SETUP_REQ</span>: Received after the server sends the initial Hello. The server reads the client's preferred name and <span class="tt">initialToken</span>. It then generates an <span class="tt">AuthToken</span>, assigns a <span class="tt"><a class="el" href="_game_definitions_8h.html#a23b5bbcdbdb8bde75298d795943efa86" title="The available Piece Types. Used from Top to Bottom, selected by the player number.">PieceType</a></span> from the available pool, adds the client to the player list and responds with SETUP_ACK.</li>
<li><span class="tt">SETTINGS_CHANGE_REQ</span>: <b>(Host Only)</b> If validated, it updates the internal <span class="tt"><a class="el" href="struct_board_data.html" title="The core data model for the game board.   Holds the grid state, rules (size/win condition),...">BoardData</a></span> and broadcasts a <span class="tt">SETTINGS_UPDATE</span> packet to all clients.</li>
<li><span class="tt">GAME_START_REQ</span>: <b>(Host Only)</b> The server resets the game board, assigns the starting player, zeros out the move history, and broadcasts a <span class="tt">GAME_START</span> packet containing the clear grid and final game settings.</li>
<li><p class="startli"><span class="tt">MOVE_REQ</span>: The core gameplay packet. The server validate that:</p><ul>
<li>It is actually this player's turn.</li>
<li>The target square is currently empty.</li>
</ul>
<p class="startli">If valid, the server updates the <span class="tt"><a class="el" href="struct_board_data.html" title="The core data model for the game board.   Holds the grid state, rules (size/win condition),...">BoardData</a></span>, appends the move to history, checks for win condition using <span class="tt"><a class="el" href="class_win_validator.html" title="Logic for detecting victory conditions on the board.   Uses a raycasting algorithm to count consecuti...">WinValidator</a></span>, and then broadcasts a <span class="tt">BOARD_STATE_UPDATE</span> or <span class="tt">GAME_END</span> packet if a win is detected.</p>
</li>
<li><span class="tt">BACK_TO_GAME_ROOM</span>: <b>(Host Only)</b> Received when the game is over and the host wants to return to the lobby. Relayed to all clients.</li>
</ul>
<p>The server additionally exposes multiple functions visible to the hosting game client containing telemetry data: <span class="tt">getTick</span>, <span class="tt">getLastTickTime</span>, <span class="tt">getAvgTickTime</span>, <span class="tt">getServerPort</span>, <span class="tt">getCurrentTurn</span>, <span class="tt">getHostingPlayerId</span>, <span class="tt">getNextPlayerId</span>, <span class="tt">getBoardSettings</span>, <span class="tt">getAvailablePieces</span>, <span class="tt">getPlayers</span> and <span class="tt">getMoves</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
Rolling Average</h2>
<p>A custom implementation of a rolling average to track <span class="tt">tick</span> times on the <span class="tt"><a class="el" href="class_internal_game_server.html" title="The authoritative server logic for the game.   Runs on a dedicated thread hosted by one of the client...">InternalGameServer</a></span>. Utilizes mutexes for thread safe access, and comes with <span class="tt">min</span>, <span class="tt">max</span> and <span class="tt">avg</span> methods built in. A deque is used for the values with a limited number of entries.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
Game Definitions</h2>
<p>Contains definitions for common objects between the client and server. Like <span class="tt"><a class="el" href="_game_definitions_8h.html#a23b5bbcdbdb8bde75298d795943efa86" title="The available Piece Types. Used from Top to Bottom, selected by the player number.">PieceType</a></span>, <span class="tt"><a class="el" href="struct_player.html" title="Represents a participant in the game.   Contains identification, statistics, and local state flags.">Player</a></span>, <span class="tt"><a class="el" href="struct_board_data.html" title="The core data model for the game board.   Holds the grid state, rules (size/win condition),...">BoardData</a></span>, <span class="tt"><a class="el" href="struct_board_square.html" title="Represents the state of a single cell on the game board.">BoardSquare</a></span> or <span class="tt"><a class="el" href="struct_move.html" title="Represents a discrete action taken by a player.   Used for history tracking and network transmission.">Move</a></span> structs.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
Network Protocol</h2>
<p>All packet are defined in this file, it also utilizes the <span class="tt">#pragma pack(push, 1)</span> macro. This prevents the compiler from messing up the padding in the structs making the network protocol work on most architectures.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md37"></a>
common/resources Directory</h2>
<p>Hold the Game Icon as well as the font in byte array form. This makes moving the binary around much easier as there is no need to bundle the resource folder along with it. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.0 </li>
  </ul>
</div>
</body>
</html>
